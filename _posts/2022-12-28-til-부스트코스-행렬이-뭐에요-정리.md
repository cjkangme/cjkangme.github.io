

---
title: [TIL] 부스트코스 행렬이 뭐에요? 정리
date: 2022-12-28 14:37:12.849 +0000
categories: [TIL]
tags: ['부스트코스', '프리코스']
description: 강의 링크 : https&#x3A;//www.boostcourse.org/ai100/lecture/739177?isDesc=false벡터 : 정수를 원소로 갖는 1차원 배열행렬 : 벡터를 원소로 갖는 2차원 배열파이썬의 numpy에서는 행 벡터가 기본 단위가 된다.이때
image: /assets/posts/2022-12-28-til-부스트코스-행렬이-뭐에요-정리/thumbnail.png

---

> 강의 링크 : https://www.boostcourse.org/ai100/lecture/739177?isDesc=false

# 행렬

- 벡터 : 정수를 원소로 갖는 1차원 배열
- 행렬 : 벡터를 원소로 갖는 2차원 배열
- 파이썬의 numpy에서는 행 벡터가 기본 단위가 된다.

- 이때 행의 개수를 n개, 열의 개수를 m개라 하여 `n x m`행렬이라 한다.
	- 한개의 행 벡터는 m개의 성분(벡터)로 이루어져 있고
    - 행렬은 n개의 행 벡터로 이루여져 있다.
    
- 행렬의 각 성분은 행과 열이라는 인덱스로 나타낼 수 있다.

```python
x = np.array([[1,-2,3],
			 [7,5,0],
             [-2,-1,2]])
x[2][0] # -2
x[1][1] # 5
```
- x<sub>ij</sub>는 i행 j열에 있다는 뜻이다.
- 파이썬에는 `x[i][j]`로 참조할 수 있다.

- 행렬의 특정 행 또는 열을 고정하면 행(열)벡터라 부른다.

## 전치행렬(transpose matrix)
- 전치행렬은 행렬 **X**의 행과 열을 뒤바꾼 행렬을 말한다.
- **X**의 전치행렬은 T(transpose) 기호를 이용해 **X**<sup>T</sup>로 표시한다.

```python
x = np.array([[1,2,3],
			  [4,5,6]])
xt = np.array([[1,4],
			   [2,5],
               [3,6]])
```

- **X**의 x<sub>ij</sub>는 **X**<sup>T</sup>의 x<sub>ji</sub>와 같다.

## 행렬의 이해

- 벡터가 공간에서 한 점을 의미한다면, 행렬은 여러 점들을 나타낸다.
	- 각각의 행 벡터가 하나의 점을 나타냄
    - 행 벡터 **x**<sub>i</sub>는 i 번째 데이터를 의미

## 행렬의 연산

- 행렬은 벡터와 동일하게 같은 모양일 경우(m과 n이 같을 경우) 덧셈, 뺄셈이 가능하다.
- 행렬의 덧셈/뺄셈은 행렬의 두 성분을 모두 더한/뺀 것과 같다.

> **X** ± **Y** = (x<sub>ij</sub> ± y<sub>ij</sub>)

- 성분곱 역시 벡터와 동일하게 계산할 수 있다.

> **X** ◎ **Y** = (x<sub>ij</sub> * y<sub>ij</sub>)
> numpy에서는 `*`로 연산한다

- 스칼라곱도 벡터와 동일하다.

> a**X** = ax<sub>ij</sub>

## 행렬의 곱셈 (matrix multiplication)

- 행렬의 곱셈(행렬곱)은 벡터와 달리 왼쪽 행렬의 i번째 행벡터와 오른쪽 행렬의 j번째 열벡터 사이의 내적을 성분으로 갖는다.
- 즉 **XY**와 **YX**의 결과는 다르다. 행렬의 곱셈에서 순서는 매우 중요하다.
- 행렬곱을 위해서는 왼쪽 행렬의 행벡터 개수와, 오른쪽 행렬의 열벡터 개수가 같아야 한다.

> **XY** = Σ<sub>k</sub>(x<sub>ik</sub> y<sub>kj</sub>)
> numpy에서는 `@`로 연산한다.

```python
x = np.array([[1,-2,3],
			 [7,5,0],
             [-2,-1,2]])
             
y = np.array([[-1,3],
			 [3,2],
             [-3,-1]])
```
위의 경우에서 **Z** = **X** @ **Y**라고 할 때
**Z**<sub>11</sub> = (**X**<sub>11</sub> \* **Y**<sub>11</sub>) + (**X**<sub>12</sub> \* **Y**<sub>21</sub>) + (**X**<sub>13</sub> \* **Y**<sub>31</sub>) = (1 \* 1) + (-2 \* 3) + (3 \* -3) = -14
**Z**<sub>12</sub> = (**X**<sub>11</sub> \* **Y**<sub>12</sub>) + (**X**<sub>12</sub> \* **Y**<sub>22</sub>) + (**X**<sub>13</sub> \* **Y**<sub>32</sub>) = (1 \* 3) + (-2 \* 2) + (3 \* -1) = -4
이와 같이 계산할 수 있다.

## 행렬의 내적

- numpy에서는 `np.inner` 함수를 통해 두 행렬의 내적을 구할 수 있다.
- 이때 numpy의 내적이란 왼쪽 행렬의 i번째 행벡터와, 오른쪽 행렬의 j번째 행벡터 사이의 내적을 성분으로 가지는 행렬을 말한다.
	- 수학에서 말하는 내적과는 다르다는 것을 알아야 한다.
    - 즉 내적을 계산한 두 행렬의 행벡터 성분수가 같아야 한다.
    
> **XY**<sup>T</sup> = Σ<sub>k</sub>(x<sub>ik</sub> y<sub>jk</sub>)

# 행렬과 데이터

## 행렬의 이해(2)

- 행렬은 벡터공간에서 두 벡터를 연결하는 일종의 **연산자**로 이해할 수 있다.
- **x** 벡터에 행렬곱 연산을 하는 것을 통해 다른 차원의 벡터 **z**로 보낼 수 있다.

> **x** @ **A** = **z**
> a<sub>11</sub>x<sub>1</sub> + a<sub>12</sub>x<sub>2</sub> + ... + a<sub>1m</sub>x<sub>m</sub> = z<sub>1</sub>
> a<sub>21</sub>x<sub>1</sub> + a<sub>22</sub>x<sub>2</sub> + ... + a<sub>2m</sub>x<sub>m</sub> = z<sub>2</sub>

- 이러한 행렬곱을 통해 패턴을 추출하거나 데이터를 합축하는 등의 작업을 할 수 있다.
- 이렇게 한 점을 한 벡터공간에서 다른 벡터공간으로 이동시키는 이동 규칙을 **선형변환(linear transform)**이라 한다.

## 역행렬(inverse matrix)

- 역행렬은 행렬 **A**의 연산을 거꾸로 되돌려 항등행렬로 만드는 행렬이다.
- **A**<sup>-1</sup>으로 표기한다.
- 역행렬은 1. 행과 열의 숫자가 같은 `n x n`의 정방행렬이어야 한다 2. 행렬식(determinant)이 0이 아닌 경우에만 계산할 수 있다.

> 항등 행렬 : 행렬의 주대각선의 원소는 1이고 나머지는 모두 0인 행렬을 말한다. 임의의 행렬이나 벡터에 항등행렬을 곱하면 자기자신을 결과로 얻는다.

> 행렬식 : 간단히 말하면 n x n의 정방행렬이 갖고 있는 어떤 특정한 값을 나타내 주는 식이다.
> 2 x 2 행렬의 경우 ad - bc가 행렬식이다

- 역행렬은 행렬곱 순서와 상관없이 항등행렬이라는 같은 결과를 출력한다.

> **AA**<sup>-1</sup> = **A**<sup>-1</sup>**A** = **I**

### numpy의 역행렬

- numpy가 제공하는 `linalg`(선형대수 함수) 라이브러리의 `inv()` 메소드를 통해 구할 수 있다.

```python
x = np.array([[1,-2,3],
			 [7,5,0],
             [-2,-1,2]])
x_inv = np.linalg.inv(x) # x의 역행렬
```

- 단 컴퓨터의 부동소수점 연산이므로 x * x<sup>-1</sup>을 했을 때 정확히 0이 아닌, 0의 가까운 숫자가 계산된다.

## 유사역행렬(pseudo-inverse)

- 무어-펜로즈(Moore-Penrose) 역행렬이라고도 한다.
- 행과 열의 숫자가 다른 경우에도 계산할 수 있다.
- **A**<sup>+</sup>라 표기한다.
- 행의 개수가 많은지, 열의 개수가 많은지에 따라 계산 방법이 다르며, 역행렬과 달리 행렬곱 순서의 영향을 받는다.

> n ≥ m (행이 열보다 많을 때)
> **A**<sup>+</sup> = (**A**<sup>T</sup>**A**)<sup>-1</sup>**A**<sup>T</sup>
> **A**<sup>+</sup>**A** = **I** 만 성립한다. (순서가 바뀌면 성립하지 않음)

> m ≥ n (열이 행보다 많을 때)
> **A**<sup>+</sup> = **A**<sup>T</sup>(**AA**<sup>T</sup>)<sup>-1</sup>
> **AA**<sup>+</sup> = **I** 만 성립한다.

### numpy의 무어-펜로즈 역행렬

- `linalg`(선형대수 함수) 라이브러리의 `pinv()` 메소드를 통해 구할 수 있다.

### 무어-펜로즈 역행렬 응용1 : 연립방정식 풀기

- m ≥ n인 경우, 즉 변수의 개수가 식의 개수보다 많은 경우 연립방정식의 해를 구할 수 있다.

> **Ax** = **b**
> ▼ 연립방정식 (m ≥ n)
> a<sub>11</sub>x<sub>1</sub> + a<sub>12</sub>x<sub>2</sub> + ... + a<sub>1m</sub>x<sub>m</sub> = b<sub>1</sub>
> a<sub>21</sub>x<sub>1</sub> + a<sub>22</sub>x<sub>2</sub> + ... + a<sub>2m</sub>x<sub>m</sub> = b<sub>2</sub>
>...
> a<sub>n1</sub>x<sub>1</sub> + a<sub>n2</sub>x<sub>2</sub> + ... + a<sub>nm</sub>x<sub>m</sub> = b<sub>n</sub>

> **x** = **A**<sup>+</sup>**b** = **A**<sup>T</sup>(**AA**<sup>T</sup>)<sup>-1</sup>**b**
> **x**의 해를 하나 구할 수 있다.

### 무어-펜로즈 역행렬 응용2 : 선형회귀분석

![img](/assets/posts/2022-12-28-til-부스트코스-행렬이-뭐에요-정리/img0.png)
<sup>출처 : 위키백과</sup>

- n ≥ m인 경우(식이 변수보다 많은 경우) 데이터를 선형모델로 해석하는 선형회귀식을 구할 수 있다.
	- 여기서 식이 많다는 것은 데이터를 나타내는 점(=행벡터)가 벡터의 차원보다 더 많다는 것이다.

> 선형회귀식 : **X**β = **y**

- 식(데이터)이 매우 많기 때문에 모든 식을 만족하는 **X**β를 찾는 것은 불가능하다. (모든 데이터가 한 선 위에 있을때만 가능)
- 이때 L2-노름을 사용하여 식과 데이터 사이의 유클리드 거리가 최소가 되는 **y hat** 값을 찾을 수 있다.

> **X**β = **ŷ**
> β = **X**<sup>+</sup>**ŷ** = (**X**<sup>T</sup>**X**)<sup>-1</sup>**X**<sup>T</sup>**ŷ**

- 파이썬에서는 sklearn의 LinearRegression 메소드를 이용할 수 있는데, 이것과 같은 결과를 가져 올 수 있다.

- 단 numpy의 `linalg.pinv()`를 이용할 때는 y절편을 고려하지 않았으므로, intercept항을 직접 추가해야한다.

> 사실 이부분은 잘 이해가 가지 않는다.
> y절편이 필요하다는 것은 알겠지만, 어떻게 추가할 수 있다는 걸까?


        